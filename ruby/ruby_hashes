METHODS OF HASH CLASS BY AJAY AGRAWAL AT BERYL SYSTEMS

Hashes :

A Hash maps each of its unique keys to a specific value. 

A Hash has certain similarities with array, but

Array index is always an integer and Hash key can be (almost) any object.

For Example :

irb(main):026:0> a= {1=>2,'joy'=>15}

irb(main):027:0> a[1]
=> 2

irb(main):028:0> a['joy']
=> 15

1. Methods For creating Hash

[] - Returns a new Hash object populated with the given objects, if any.

For Example :

irb(main):037:0> a = {a:15,b:85,ram:85}
irb(main):038:0> Hash[a]
=> {:a=>15, :b=>85, :ram=>85}


irb(main):037:0> a = {a:15,b:85,ram:85}
irb(main):038:0> Hash[a]
=> {:a=>15, :b=>85, :ram=>85}


-> new

Returns a new empty Hash object.

h = new.Hash

With default values :

irb(main):074:0> h = Hash.new{[2,25,'joy',98]}
irb(main):075:0> h
=> {}
irb(main):076:0> h[2]
=> [2, 25, "joy", 98]
irb(main):077:0> h[1]
=> [2, 25, "joy", 98]


----------------------------------------------------------------------------------------------------------------------------

2. try_convert

irb(main):092:0> a = [ [:abc,2],[:fds,8]]
irb(main):093:0> a.class
=> Array
irb(main):095:0> Hash.try_convert(a)                   #Returns nil if obj does not respond to :to_hash
=> nil


irb(main):101:0> b={'abc'=>25,'cdf'=>258}
irb(main):102:0> b.class
=> Hash
irb(main):104:0> Hash.try_convert(b)                   #If obj is a Hash object, returns obj.
=> {"abc"=>25, "cdf"=>258}


-----------------------------------------------------------------------------------------------------------------------------

3. <,>,<=,>=,==

irb(main):113:0> h1 = {25=>58, 26=>59, 27=>60}
irb(main):114:0> h2 = {27=>60,25=>58}

irb(main):115:0> h1 >= h2                         #Return True , if h2 is subset of h1
=> true

irb(main):116:0> h2 >= h1                         #Return False , because h1 is not subset of h1
=> false

irb(main):117:0> h2 >= h2                         #Return True , because h2 is subset for itself
=> true

------------------------------------------------------------------------------------------------------------------------------

irb(main):118:0> h2 > h1                          #Return False because h1 is not proper subset of h2
=> false

irb(main):119:0> h1 > h2                          #Return True because h2 is proper subset of h1
=> true

irb(main):120:0> h2 > h2                          #Return False because h2 is not proper subset for itself
=> false

-------------------------------------------------------------------------------------------------------------------------------

irb(main):121:0> h1 = {25=>58, 26=>59, 27=>60}
irb(main):122:0> h2 = {27=>60,25=>58,29=>59}
irb(main):123:0> h1 == h2                              #Return false because , the key for 59 is differ in both
=> false


irb(main):124:0> h1 = {25=>58, 26=>59, 27=>60}         #Return True because , both are same. 
irb(main):125:0> h2 = {27=>60,25=>58,26=>59}
irb(main):126:0> h1 == h2
=> true

--------------------------------------------------------------------------------------------------------------------------------

irb(main):135:0> h2<h1                                 #Return true because h1 is superset for h1
=> true

irb(main):136:0> h1<h2                                 #Return false because h1 is not less than h2
=> false

irb(main):137:0> h1<h1                                 #Return false because h1 is not less than to itself
=> false

--------------------------------------------------------------------------------------------------------------------------------

irb(main):139:0> h2<=h1                                #Return true because h2 is less than or equals to h1
=> true

irb(main):140:0> h1<=h2                                #Return false because h1 is not less than or equals to h2
=> false

irb(main):141:0> h1<=h1                                #Return true because h1 is less than or equals to itself
=> true

----------------------------------------------------------------------------------------------------------------------------------

4. any

=> {25=>58, 26=>59, 27=>60}

irb(main):168:0> h1.any?([25, 58])                     #Return true if key and thats value is same.
=> true

irb(main):169:0> h1.any?([25, 59])
=> false

irb(main):170:0> h1.any?{|key, value| value<50}        #Return true because codition is not true for any value
=> false

irb(main):171:0> h1.any?{|key, value| value>50}        #Return True because atleast one value satisfies the condition
=> true

----------------------------------------------------------------------------------------------------------------------------------

5. assoc

irb(main):172:0> h1.assoc(25)                          #If the given key is found, returns a 2-element Array containing that key and its value
=> [25, 58]

irb(main):173:0> h1.assoc(24)                          #Returns nil if key key is not found.
=> nil

----------------------------------------------------------------------------------------------------------------------------------

6. clear

irb(main):174:0> h1
=> {25=>58, 26=>59, 27=>60}

irb(main):175:0> h1.clear                              #It will remove all hash entities
=> {}

-----------------------------------------------------------------------------------------------------------------------------------

7. compact

irb(main):178:0> h
=> {:joy=>nil, :ram=>1, :shyam=>2, :radhey=>nil}

irb(main):179:0> h.compact                             #Returns a copy of self with all nil-valued entries removed.
=> {:ram=>1, :shyam=>2}

irb(main):180:0> h
=> {:joy=>nil, :ram=>1, :shyam=>2, :radhey=>nil}

-------------------------------------------------------------------------------

irb(main):181:0> h.compact!                            #Returns self with all its nil-valued entries removed (in place)
=> {:ram=>1, :shyam=>2}

irb(main):182:0> h
=> {:ram=>1, :shyam=>2}


--------------------------------------------------------------------------------------------------------------------------------------

8. compare_by_identity

irb(main):183:0> s1 = 'x'
irb(main):184:0> s2 = 'x'
irb(main):185:0> h={}
irb(main):186:0> h.class
=> Hash

irb(main):187:0> h[s1]=1
irb(main):188:0> h[s2]=2                      #By default, these two object are considered to be the same key, so s2 will overwrite s1.
irb(main):189:0> h
=> {"x"=>2}

irb(main):190:0> h.compare_by_identity?      #Returns true if compare_by_identity has been called, false otherwise.
=> false
irb(main):191:0> h.compare_by_identity        #After calling compare_by_identity, the keys are considered to be different
=> {"x"=>2}

irb(main):192:0> h
=> {"x"=>2}

irb(main):193:0> h[s1]=1                      #So, now they don't overwrite 
irb(main):194:0> h[s2]=2
irb(main):195:0> h.compare_by_identity?
=> true

irb(main):196:0> h
=> {"x"=>2, "x"=>1, "x"=>2}


------------------------------------------------------------------------------------------------------------------------------------

9. default 

irb(main):201:0> h = {}

irb(main):202:0> h.default = false             #set default value for h is false.

irb(main):203:0> h.default
=> false

irb(main):204:0> h[25]
=> false

--------------------------------------------------------------------------

irb(main):205:0> h1 = Hash.new{|hash ,key| hash[key] = "No value for #{key}"}  #If key is given, returns the default value for key

irb(main):207:0> h1[:hello]                    
=> "No value for hello"

------------------------------------------------------------------------------------------------------------------------------------

10. delete & delete_if

irb(main):227:0> h = {joy: nil, ram: 1, shyam: 2, radhey: nil}
irb(main):228:0> h.delete(:joy)                                  #delete the value on given key
=> nil
irb(main):229:0> h
=> {:ram=>1, :shyam=>2, :radhey=>nil}

------------------------------------------------------------------------

irb(main):230:0> h = {joy: nil, ram: 1, shyam: 2, radhey: nil}
irb(main):231:0> h.delete_if{|key, value| value==1}              #delete if condition is true for value
=> {:joy=>nil, :shyam=>2, :radhey=>nil}
irb(main):232:0> h
=> {:joy=>nil, :shyam=>2, :radhey=>nil}


--------------------------------------------------------------------------------------------------------------------------------------

11. dig

irb(main):238:0> h
=> {1=>{2=>{3=>4}}}

irb(main):240:0> h.dig(1)                            #Finds and returns the object in nested objects that is specified by key and identifiers
=> {2=>{3=>4}}

irb(main):241:0> h.dig(1,2)
=> {3=>4}

irb(main):242:0> h.dig(1,2,3)
=> 4


----------------------------------------------------------------------------------------------------------------------------------------

12. each , each_pair , each_key , each_value

h => {:joy=>0, :ram=>1, :shyam=>2, :radhey=>3}


irb(main):249:0> h.each_pair{|key,value| puts "#{key} : #{value}"}       #each_pair
joy : 0
ram : 1
shyam : 2
radhey : 3


irb(main):251:0> h.each_key{|key| puts key }                              #each_key only returns keys.
joy
ram
shyam
radhey


irb(main):252:0> h.each{|key, value| puts  "#{key} : #{value}" }          #each
joy : 0
ram : 1
shyam : 2
radhey : 3


irb(main):254:0> h.each_value{|value| puts value }                         #each value only returns values.
0
1
2
3


-------------------------------------------------------------------------------------------------------------------------------------

13. empty? 

It will return true , only if hash is empty otherwise false.

Example :

irb(main):257:0> {ram: 2}.empty?        
=> false

irb(main):258:0> {}.empty?
=> true

--------------------------------------------------------------------------------------------------------------------------------------

14. eql?

irb(main):264:0> h1 = {1=>2,3=>4,5=>6}
irb(main):265:0> h2 = {1=>2,5=>6,3=>4}
irb(main):266:0> h3 = {1=>2,3=>4,5=>6}

irb(main):267:0> h1.eql?(h2)       #if sequence is different , it also return true. because thats not have indexes.
=> true

irb(main):268:0> h1.eql?(h3)
=> true


---------------------------------------------------------------------------------------------------------------------------------------

15. except

h = { a: 100, b: 200, c: 300 }
h.except(:a)          #=> {:b=>200, :c=>300}


---------------------------------------------------------------------------------------------------------------------------------------

16. fetch

irb(main):284:0> h = {joy: 0, ram: 1, shyam: 2, radhey: 3}

irb(main):285:0> h.fetch(:joy)                                  #fetch value by key
=> 0

irb(main):286:0> h.fetch(:ram)
=> 1

irb(main):288:0> h.fetch(:none){|key| "No key Found #{key}"}    #if key is not found, return the given message 
=> "No key Found none"

irb(main):289:0> h.fetch(:ram,:joy)                                 
=> 1

irb(main):290:0> h.fetch_values(:ram,:joy)                      #fetch more than 1 value by keys
=> [1, 0]


----------------------------------------------------------------------------------------------------------------------------------------

17. select or filter

filter is an alias of select.

irb(main):293:0> h = {joy: 0, ram: 1, shyam: 2, radhey: 3}

irb(main):294:0> h.select{|key,value| value>2}
=> {:radhey=>3}

irb(main):295:0> h.select{|key,value| value>1}
=> {:shyam=>2, :radhey=>3}

irb(main):296:0> h.filter{|key,value| value>1}
=> {:shyam=>2, :radhey=>3}

-----------------------------------------------------------------------------------------------------------------------------------------


