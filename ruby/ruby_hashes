METHODS OF HASH CLASS BY AJAY AGRAWAL AT BERYL SYSTEMS

Hashes :

A Hash maps each of its unique keys to a specific value. 

A Hash has certain similarities with array, but

Array index is always an integer and Hash key can be (almost) any object.

For Example :

irb(main):026:0> a= {1=>2,'joy'=>15}

irb(main):027:0> a[1]
=> 2

irb(main):028:0> a['joy']
=> 15

1. Methods For creating Hash

[] - Returns a new Hash object populated with the given objects, if any.

For Example :

irb(main):037:0> a = {a:15,b:85,ram:85}
irb(main):038:0> Hash[a]
=> {:a=>15, :b=>85, :ram=>85}


irb(main):037:0> a = {a:15,b:85,ram:85}
irb(main):038:0> Hash[a]
=> {:a=>15, :b=>85, :ram=>85}


-> new

Returns a new empty Hash object.

h = new.Hash

With default values :

irb(main):074:0> h = Hash.new{[2,25,'joy',98]}
irb(main):075:0> h
=> {}
irb(main):076:0> h[2]
=> [2, 25, "joy", 98]
irb(main):077:0> h[1]
=> [2, 25, "joy", 98]


----------------------------------------------------------------------------------------------------------------------------

2. try_convert

irb(main):092:0> a = [ [:abc,2],[:fds,8]]
irb(main):093:0> a.class
=> Array
irb(main):095:0> Hash.try_convert(a)                   #Returns nil if obj does not respond to :to_hash
=> nil


irb(main):101:0> b={'abc'=>25,'cdf'=>258}
irb(main):102:0> b.class
=> Hash
irb(main):104:0> Hash.try_convert(b)                   #If obj is a Hash object, returns obj.
=> {"abc"=>25, "cdf"=>258}


-----------------------------------------------------------------------------------------------------------------------------

3. <,>,<=,>=,==

irb(main):113:0> h1 = {25=>58, 26=>59, 27=>60}
irb(main):114:0> h2 = {27=>60,25=>58}

irb(main):115:0> h1 >= h2                         #Return True , if h2 is subset of h1
=> true

irb(main):116:0> h2 >= h1                         #Return False , because h1 is not subset of h1
=> false

irb(main):117:0> h2 >= h2                         #Return True , because h2 is subset for itself
=> true

------------------------------------------------------------------------------------------------------------------------------

irb(main):118:0> h2 > h1                          #Return False because h1 is not proper subset of h2
=> false

irb(main):119:0> h1 > h2                          #Return True because h2 is proper subset of h1
=> true

irb(main):120:0> h2 > h2                          #Return False because h2 is not proper subset for itself
=> false

-------------------------------------------------------------------------------------------------------------------------------

irb(main):121:0> h1 = {25=>58, 26=>59, 27=>60}
irb(main):122:0> h2 = {27=>60,25=>58,29=>59}
irb(main):123:0> h1 == h2                              #Return false because , the key for 59 is differ in both
=> false


irb(main):124:0> h1 = {25=>58, 26=>59, 27=>60}         #Return True because , both are same. 
irb(main):125:0> h2 = {27=>60,25=>58,26=>59}
irb(main):126:0> h1 == h2
=> true

--------------------------------------------------------------------------------------------------------------------------------

irb(main):135:0> h2<h1                                 #Return true because h1 is superset for h1
=> true

irb(main):136:0> h1<h2                                 #Return false because h1 is not less than h2
=> false

irb(main):137:0> h1<h1                                 #Return false because h1 is not less than to itself
=> false

--------------------------------------------------------------------------------------------------------------------------------

irb(main):139:0> h2<=h1                                #Return true because h2 is less than or equals to h1
=> true

irb(main):140:0> h1<=h2                                #Return false because h1 is not less than or equals to h2
=> false

irb(main):141:0> h1<=h1                                #Return true because h1 is less than or equals to itself
=> true

----------------------------------------------------------------------------------------------------------------------------------

4. any

=> {25=>58, 26=>59, 27=>60}

irb(main):168:0> h1.any?([25, 58])                     #Return true if key and thats value is same.
=> true

irb(main):169:0> h1.any?([25, 59])
=> false

irb(main):170:0> h1.any?{|key, value| value<50}        #Return true because codition is not true for any value
=> false

irb(main):171:0> h1.any?{|key, value| value>50}        #Return True because atleast one value satisfies the condition
=> true

----------------------------------------------------------------------------------------------------------------------------------

5. assoc

irb(main):172:0> h1.assoc(25)                          #If the given key is found, returns a 2-element Array containing that key and its value
=> [25, 58]

irb(main):173:0> h1.assoc(24)                          #Returns nil if key key is not found.
=> nil

----------------------------------------------------------------------------------------------------------------------------------

6. clear

irb(main):174:0> h1
=> {25=>58, 26=>59, 27=>60}

irb(main):175:0> h1.clear                              #It will remove all hash entities
=> {}

-----------------------------------------------------------------------------------------------------------------------------------

7. compact

irb(main):178:0> h
=> {:joy=>nil, :ram=>1, :shyam=>2, :radhey=>nil}

irb(main):179:0> h.compact                             #Returns a copy of self with all nil-valued entries removed.
=> {:ram=>1, :shyam=>2}

irb(main):180:0> h
=> {:joy=>nil, :ram=>1, :shyam=>2, :radhey=>nil}

-------------------------------------------------------------------------------

irb(main):181:0> h.compact!                            #Returns self with all its nil-valued entries removed (in place)
=> {:ram=>1, :shyam=>2}

irb(main):182:0> h
=> {:ram=>1, :shyam=>2}


--------------------------------------------------------------------------------------------------------------------------------------

8. compare_by_identity

irb(main):183:0> s1 = 'x'
irb(main):184:0> s2 = 'x'
irb(main):185:0> h={}
irb(main):186:0> h.class
=> Hash

irb(main):187:0> h[s1]=1
irb(main):188:0> h[s2]=2                      #By default, these two object are considered to be the same key, so s2 will overwrite s1.
irb(main):189:0> h
=> {"x"=>2}

irb(main):190:0> h.compare_by_identity?
=> false
irb(main):191:0> h.compare_by_identity        #After calling compare_by_identity, the keys are considered to be different
=> {"x"=>2}

irb(main):192:0> h
=> {"x"=>2}

irb(main):193:0> h[s1]=1                      #So, now they don't overwrite 
irb(main):194:0> h[s2]=2
irb(main):195:0> h.compare_by_identity?
=> true

irb(main):196:0> h
=> {"x"=>2, "x"=>1, "x"=>2}


------------------------------------------------------------------------------------------------------------------------------------
